#
# Copyright 2014, NICTA
#
# This software may be distributed and modified according to the terms of
# the BSD 2-Clause license. Note that NO WARRANTY is provided.
# See "LICENSE_BSD2.txt" for details.
#
# @TAG(NICTA_BSD)
#

/*# Ignore the following line. It is intended to apply to the output of this
    template.
#*/
# THIS FILE IS AUTOMATICALLY GENERATED. YOUR EDITS WILL BE OVERWRITTEN.

/*# When modifying this template be particularly careful. The awkward syntax of
    both the templating language and GNU Make come together to make it very
    easy to introduce unreadable code in this context.
#*/

/*# Various macros to make constructing makefile rules easier. #*/
/*- macro rule_cp(target, dependencies) -*/
/*? target ?*/: /*? dependencies ?*/
	@echo " [CP] $(notdir $@)"
	${Q}mkdir -p $(dir $@)
	${Q}echo "#line 1 \"$<\"" >$@
	${Q}cat "$<" >>"$@"
/*- endmacro -*/

/*- macro rule_gen(target, dependencies, item, cfiles_append=None, platform='seL4', preprocessor=None) -*/
/*- if cfiles_append -*/
/*? cfiles_append ?*/_CFILES += /*? target ?*/
/*- endif -*/
.DELETE_ON_ERROR: /*? target ?*/
/*? target ?*/: /*? dependencies ?*/
	@echo " [GEN] $(notdir $@)"
	${Q}mkdir -p $(dir $@)
	${Q}camkes.sh runner \
        ${CAMKES_FLAGS} \
        /*- for inc in options.import_path -*/ --import-path /*? inc ?*/ /*- endfor -*/ \
        --file /*? options.file[0].name ?*/ \
        --item /*? item ?*/ \
        --outfile "$@" \
        --platform /*? platform ?*/
	/*- if preprocessor != None -*/
	@echo " [PP] $(notdir $@)"
	${Q}/*? preprocessor ?*/
	/*- endif -*/
/*- endmacro -*/

# All targets need to be rebuilt if the source CAmkES descriptions change.
${TARGETS}: /*? ' '.join(imported) ?*/

/*- set instances = me.composition.instances -*/
/*- set connections = me.composition.connections -*/

/*# The terms 'group' and 'address space' are currently synonymous. We can
 *# derive the groups by collecting all the instances' address spaces.
 #*/
/*- set groups = set(map(lambda('x: x.address_space'), filter(lambda('x: not x.type.hardware'), instances))) -*/

# Generate the policy label mapping if the user requested it.
ifeq (${CONFIG_CAMKES_LABEL_MAPPING},y)
LABEL_MAPPING=$(patsubst %.cdl,%.json,$(firstword ${TARGETS}))
${TARGETS}: ${LABEL_MAPPING}
${LABEL_MAPPING}: /*? ' '.join(imported) ?*/ /*- for g in groups -*/ /*- set p = Perspective(group=g) -*/ ${SEL4_BINDIR}//*? p['elf_name'] ?*/ /*- endfor -*/
	@echo " [GEN] $(notdir $@)"
	$(Q)camkes.sh runner \
        ${CAMKES_FLAGS} \
        --file /*? options.file[0].name ?*/ \
        /*- for inc in options.import_path -*/ --import-path /*? inc ?*/ /*- endfor -*/ \
        --item label-mapping \
        /*- for g in groups -*/ \
            /*- set p = Perspective(group=g) -*/ \
            --elf /*? p['elf_name'] ?*/ \
        /*- endfor -*/ \
        --outfile "$@" \
        --platform seL4
endif

# Static component files provided by the user.
/*- for i in instances if not i.type.hardware -*/
/*? i.name ?*/_CFILES += \
    $(/*? i.type.name ?*/_CFILES:%=$(abspath ${BUILD_DIR})/src//*? i.name ?*//static/%)
/*? i.name ?*/_CXXFILES += \
    $(/*? i.type.name ?*/_CXXFILES:%=$(abspath ${BUILD_DIR})/src//*? i.name ?*//static/%)
/*? i.name ?*/_OFILES += \
    $(/*? i.type.name ?*/_OFILES:%=$(abspath ${BUILD_DIR})/src//*? i.name ?*//static/%)
/*? i.name ?*/_ASMFILES += \
    $(/*? i.type.name ?*/_ASMFILES:%=$(abspath ${BUILD_DIR})/src//*? i.name ?*//static/%)
/*? i.name ?*/_HFILES += \
    $(/*? i.type.name ?*/_HFILES:%=$(abspath ${BUILD_DIR})/include//*? i.name ?*//static/%)
/*? rule_cp('$(abspath ${BUILD_DIR})/src/' + i.name + '/static/%', '${SOURCE_DIR}/%') ?*/
/*? rule_cp('$(abspath ${BUILD_DIR})/include/' + i.name + '/static/%', '${SOURCE_DIR}/%') ?*/
/*- endfor -*/

# Library dependencies required by glue code.
/*- for i in instances -*/
/*? i.name ?*/_instance_LIBS += ${/*? i.type.name ?*/_LIBS} ${CAMKES_CORE_LIBS}
/*- endfor -*/
/*- for g in groups -*/
/*? g ?*/_group_LIBS = ${CAMKES_CORE_LIBS}
/*- endfor -*/

# Instance entry point generation. Note that this is the instance's C entry
# point, as distinct from both its containing group's C entry point and the
# group's initial assembly entry point.
/*- for i in instances -*/
/*? rule_gen('$(abspath ${BUILD_DIR})/src/' + i.name + '/generated/' + i.type.name + '.c', ' '.join(imported), i.name + '.source', i.name) ?*/
/*- if configuration and filter(lambda('x: x.instance == \'%s\' and x.attribute == \'simple\' and x.value ==\'true\'' % (i.name)), configuration.settings) -*/
    /*? rule_gen('$(abspath ${BUILD_DIR})/src/' + i.name + '/generated/' + i.type.name + '.simple.c', ' '.join(imported), i.name + '.simple', i.name) ?*/
/*- endif -*/
/*? rule_gen('$(abspath ${BUILD_DIR})/include/' + i.name + '/generated/' + i.type.name + '.h', ' '.join(imported), i.name + '.header') ?*/
/*- endfor -*/

# Connection code generation.
/*- set from_names = [] -*/
/*- set to_names = [] -*/
/*- for c in connections -*/
/*- if not ('%s_%s' % (c.from_instance.name, c.from_interface.name)) in from_names -*/
/*? rule_gen('$(abspath ${BUILD_DIR})/src/' + c.from_instance.name + '/generated/' + c.from_interface.name + '_' + c.type.name + '.c', ' '.join(imported), c.name + '.from.source', c.from_instance.name) ?*/
/*- do from_names.append(('%s_%s' % (c.from_instance.name, c.from_interface.name))) -*/
/*- endif -*/
/*- if not ('%s_%s' % (c.to_instance.name, c.to_interface.name)) in to_names -*/
/*? rule_gen('$(abspath ${BUILD_DIR})/src/' + c.to_instance.name + '/generated/' + c.to_interface.name + '_' + c.type.name + '.c', ' '.join(imported), c.name + '.to.source', c.to_instance.name) ?*/
/*- do to_names.append(('%s_%s' % (c.to_instance.name, c.to_interface.name))) -*/
/*- endif -*/

ifeq (${CONFIG_CAMKES_PRUNE_GENERATED},y)
/*# We need to provide specialised targets for the pruned c_pp files *and* o
 *# files so the generic targets in tools/common/camkes.mk won't match.
 #*/

/*# Pruned C files (from) #*/
/*- set prefix = '$(abspath ${BUILD_DIR})/src/%s/generated/%s_%s' % (c.from_instance.name, c.from_interface.name, c.type.name) -*/
/*? prefix ?*/.o: /*? prefix ?*/.pruned.c_pp
	@$(if $(filter-out 0,${V}),$(warning Using CAmkES generic .o target),)
	@echo " [CC] $(notdir $@)"
	$(Q)mkdir -p $(dir $@)
	$(Q)$(CC) -x c $(CFLAGS) $(foreach v,$(filter-out $<,$^),$(patsubst %,-I%,$(abspath $(dir ${v})))) -c $< -o $@
/*? prefix ?*/.pruned.c_pp: /*? prefix ?*/.c_pp
	@echo " [PRUNE] $(notdir $@)"
	${Q}LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:${CONFIG_CAMKES_LLVM_PATH}/lib prune --keep /*? c.from_interface.name ?*/__run \
	/*- if c.from_interface in c.from_instance.type.emits -*/ \
	    --keep /*? c.from_interface.name ?*/_emit_underlying \
	/*- elif c.from_interface in c.from_instance.type.dataports -*/ \
	    --keep /*? c.from_interface.name ?*/_wrap_ptr \
	    --keep /*? c.from_interface.name ?*/_unwrap_ptr \
	/*- elif c.from_interface in c.from_instance.type.uses -*/ \
	    /*- for m in c.from_interface.type.methods -*/ \
	        --keep /*? c.from_interface.name ?*/_/*? m.name ?*/ \
	    /*- endfor -*/ \
	/*- endif -*/ \
	$(foreach i,${PRUNER_BLACKLIST},--blacklist $i) --output "$@" "$<"

/*# Pruned C files (to) #*/
/*- set prefix = '$(abspath ${BUILD_DIR})/src/%s/generated/%s_%s' % (c.to_instance.name, c.to_interface.name, c.type.name) -*/
/*? prefix ?*/.o: /*? prefix ?*/.pruned.c_pp
	@$(if $(filter-out 0,${V}),$(warning Using CAmkES generic .o target),)
	@echo " [CC] $(notdir $@)"
	$(Q)mkdir -p $(dir $@)
	$(Q)$(CC) -x c $(CFLAGS) $(foreach v,$(filter-out $<,$^),$(patsubst %,-I%,$(abspath $(dir ${v})))) -c $< -o $@
/*? prefix ?*/.pruned.c_pp: /*? prefix ?*/.c_pp
	@echo " [PRUNE] $(notdir $@)"
	${Q}LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:${CONFIG_CAMKES_LLVM_PATH}/lib prune --keep /*? c.to_interface.name ?*/__run \
	/*- if c.to_interface in c.to_instance.type.consumes -*/ \
	    --keep /*? c.to_interface.name ?*/_poll \
	    --keep /*? c.to_interface.name ?*/_wait \
	/*- elif c.to_interface in c.to_instance.type.dataports -*/ \
	    --keep /*? c.to_interface.name ?*/_wrap_ptr \
	    --keep /*? c.to_interface.name ?*/_unwrap_ptr \
	/*- elif c.to_interface in c.to_instance.type.provides -*/ \
	    /*# nothing extra required #*/ \
	/*- endif -*/ \
	$(foreach i,${PRUNER_BLACKLIST},--blacklist $i) --output "$@" "$<"
endif

/*# Theory generation #*/
/*- set fromthy = '$(abspath ${BUILD_DIR})/thy/%s/generated/%s.thy' % (c.from_instance.name, c.from_interface.name) -*/
/*? rule_gen(fromthy, ' '.join(imported), '%s.from.theory' % c.name, platform='autocorres', preprocessor='${TPP} --in-place "$@"') ?*/
ifeq (${CONFIG_CAMKES_THYS},y)
${TARGETS}: /*? fromthy ?*/
endif
/*- set tothy = '$(abspath ${BUILD_DIR})/thy/%s/generated/%s.thy' % (c.to_instance.name, c.to_interface.name) -*/
/*? rule_gen(tothy, ' '.join(imported), '%s.to.theory' % c.name, platform='autocorres', preprocessor='${TPP} --in-place "$@"') ?*/
ifeq (${CONFIG_CAMKES_THYS},y)
${TARGETS}: /*? tothy ?*/
endif
/*- endfor -*/

# Each component file may depend on the per-component generated header.
/*- for i in instances if not i.type.hardware -*/
$(/*? i.name ?*/_CFILES:%.c=%.o): \
    $(abspath ${BUILD_DIR})/include//*? i.name ?*//generated//*? i.type.name ?*/.h
$(/*? i.name ?*/_CXXFILES:%.cxx=%.o): \
    $(abspath ${BUILD_DIR})/include//*? i.name ?*//generated//*? i.type.name ?*/.h
# In case we are running CPP separately:
$(/*? i.name ?*/_CFILES:%.c=%.c_pp): \
    $(abspath ${BUILD_DIR})/include//*? i.name ?*//generated//*? i.type.name ?*/.h
/*- endfor -*/

# Each (generated or static) component file compilation may depend on the
# user-provided code.
/*- for i in instances if not i.type.hardware -*/
$(/*? i.name ?*/_CFILES:%.c=%.o): ${/*? i.name ?*/_HFILES} ${/*? i.name ?*/_CFILES} ${/*? i.name ?*/_CXXFILES} ${/*? i.name ?*/_ASMFILES}
$(/*? i.name ?*/_CXXFILES:%.cxx=%.o): ${/*? i.name ?*/_HFILES} ${/*? i.name ?*/_CFILES} ${/*? i.name ?*/_CXXFILES} ${/*? i.name ?*/_ASMFILES}
# In case we are running CPP separately:
$(/*? i.name ?*/_CFILES:%.c=%.c_pp): ${/*? i.name ?*/_HFILES} ${/*? i.name ?*/_CFILES} ${/*? i.name ?*/_ASMFILES}
/*- endfor -*/

# A target for each binary intended to match the one in common.mk. We introduce
# our own here because we (potentially) need to link different libraries for
# different components.
/*- for i in instances if not i.type.hardware -*/
/*? i.name ?*/_instance_LDFLAGS := \
    ${NK_LDFLAGS} \
    $(SEL4_LIBDIR:%=-L%) \
    ${CFLAGS} \
    ${STARTGROUP} \
    $(/*? i.name ?*/_instance_LIBS:%=-l%) \
    ${LIBGCC} \
    ${ENDGROUP} \
    -static -nostdlib \
    -u _camkes_start \
    -e _camkes_start \
    -Wl,--script=${BUILD_DIR}/linker.lds

/*# Only incrementally link if this instance is going on to become part of a
 *# group.
 #*/
/*- if i.address_space != i.name -*/
/*? i.name ?*/_instance_LDFLAGS += -Wl,--relocatable
/*- endif -*/

# Memory allocation debugging. Note these symbols only need to be wrapped at
# the instance level because they are resolved in the first link.
ifeq (${CONFIG_CAMKES_DEBUG_MALLOC},y)
/*? i.name ?*/_instance_LDFLAGS += $(foreach i,malloc free realloc calloc,-Wl,--wrap=$i)
endif

CRTOBJFILES ?= $(SEL4_LIBDIR)/crt1.o $(SEL4_LIBDIR)/crti.o $(shell $(CC) $(CFLAGS) $(CPPFLAGS)  -print-file-name=crtbegin.o)
FINOBJFILES ?= $(shell $(CC) $(CFLAGS) $(CPPFLAGS) -print-file-name=crtend.o) $(SEL4_LIBDIR)/crtn.o

/*? i.name ?*/.instance.bin: $(/*? i.name ?*/_CFILES:%.c=%.o) $(/*? i.name ?*/_CXXFILES:%.cxx=%.o) $(/*? i.name ?*/_ASMFILES:%.S=%.o) $(/*? i.name ?*/_OFILES) \
	$(/*? i.name ?*/_instance_LIBS:%=%.a)
	@echo " [LD] $(notdir $@)"
	${Q}${CC} $(CRTOBJFILES) $(filter %.o,$^) $(FINOBJFILES) ${/*? i.name ?*/_instance_LDFLAGS} -o $@
/*- set p = Perspective(group=i.address_space) -*/
/*? p['elf_name'] ?*/: /*? i.name ?*/.instance-copy.bin
/*# The actual recipe for the above target is generated below. Remember, groups
 *# and address spaces are essentially the same thing at this point.
 #*/
/*- endfor -*/

/*- for g in groups -*/
/*? g ?*/_group_LDFLAGS += \
    ${NK_LDFLAGS} \
    $(SEL4_LIBDIR:%=-L%) \
    $(CFLAGS:-flto= ) \
    ${STARTGROUP} \
    $(/*? g ?*/_group_LIBS:%=-l%) \
    ${LIBGCC} \
    ${ENDGROUP} \
    -static -nostdlib \
    -u _camkes_start \
    -e _camkes_start
/*- endfor -*/

# CapDL generation. This assumes that the last element in TARGETS is a CapDL
# spec.
.DELETE_ON_ERROR: $(lastword ${TARGETS})
$(firstword ${TARGETS}): /*- for g in groups -*/ /*- set p = Perspective(group=g) -*/ ${SEL4_BINDIR}//*? p['elf_name'] ?*/ /*- endfor -*/
	@echo " [GEN] $(notdir $@)"
	$(Q)mkdir -p $(SEL4_BINDIR)
	$(Q)camkes.sh runner \
        ${CAMKES_FLAGS} \
        --file "${SOURCE_DIR}/${ADL}" \
        --import-path ${SOURCE_DIR}/../../tools/camkes/include/builtin \
        --item capdl \
        /*- for g in groups -*/ \
            /*- set p = Perspective(group=g) -*/ \
            --elf /*? p['elf_name'] ?*/ \
        /*- endfor -*/ \
        --outfile "$@"

/*- for g in groups -*/
/*# This weird re-staging of everything in SEL4_BINDIR is here because the
 *# CapDL initialiser looks for the binaries it's going to boot here. It's
 *# awkward that we can't just tell it this information directly.
 #*/
/*- set p = Perspective(group=g) -*/
${SEL4_BINDIR}//*? p['elf_name'] ?*/: /*? p['elf_name'] ?*/
	${Q}mkdir -p "${SEL4_BINDIR}"
	@echo " [STAGE] $(notdir $@)"
	${Q} cp "$<" "$@"

/*? g ?*/_group_bin: # Dependencies for this are above.
	@if [ $(words $^) -eq 1 ]; then echo " [CP] $@"; else echo " [LD] $@"; fi
ifeq (${CONFIG_LINK_TIME_OPTIMISATIONS},y)
	@if [ $(words $^) -ne 1 ]; then echo "Warning: LTO will not be applied to $@" >&2; fi
endif
	${Q}if [ $(words $^) -eq 1 ]; then cp "$<" "$@"; else ${CC} $^ ${/*? g ?*/_group_LDFLAGS} -o $@; fi
/*- endfor -*/

# We need to apply objcopy to each component instance's ELF before we link them
# into a flattened binary in order to avoid symbol collision. Note that when we
# mangle symbols, we use the prefix 'camkes ' to avoid colliding with any
# user-provided symbols.
/*- set instancelist = [] -*/
/*- for i in instances if not i.type.hardware -*/
/*- set pre = NameMangling.Perspective(phase=NameMangling.TEMPLATES, instance=i.name, group=i.address_space) -*/
/*- set post = NameMangling.Perspective(phase=NameMangling.FILTERS, instance=i.name, group=i.address_space) -*/
/*? i.name ?*/.instance-copy.bin: /*- for i in instances if not i.type.hardware -*/ /*? i.name ?*/.instance.bin /*- endfor -*/
	@echo " [OBJCOPY] $@"
	# Brace yourself. This is going to be a bumpy ride.
	${OBJCOPY} \
        \
        /*# Rename mains that will need to be located (by symbol name) by logic
         *# in the runner.
         #*/ \
        --redefine-sym "/*? pre['entry_symbol'] ?*/"="/*? post['entry_symbol'] ?*/" \
        --redefine-sym "/*? pre['tls_symbol'] ?*/"="/*? post['tls_symbol'] ?*/" \
        \
        /*# Use a dummy impossible symbol of the empty string here, because
         *# marking one symbol as 'keep global' causes all others to be demoted
         *# to local. This allows us to avoid symbol collisions from
         *# user-provided symbols.
         #*/ \
        --keep-global-symbol "" \
        \
        /*# Rename the DMA pools so they don't collide. #*/ \
        --redefine-sym "/*? pre['dma_pool_symbol'] ?*/"="/*? post['dma_pool_symbol'] ?*/" \
        \
        /*# Rename dataports so they don't collide. These symbols can be
         *# localised, but they need to be uniquely locatable for the filter
         *# that ensures they map to the same underlying frame.
         #*/ \
        /*- for d in i.type.dataports -*/ \
            /*- set pre = NameMangling.Perspective(phase=NameMangling.TEMPLATES, instance=i.name, dataport=d.name) -*/ \
            /*- set post = NameMangling.Perspective(phase=NameMangling.FILTERS, instance=i.name, dataport=d.name) -*/ \
            --redefine-sym "/*? pre['dataport_symbol'] ?*/"="/*? post['dataport_symbol'] ?*/" \
        /*- endfor -*/ \
        \
        /*- for c in connections -*/ \
            \
            /*- if c.type.name == 'seL4DirectCall' -*/ \
                \
                /*# For all 'from' connection ends (calls to unresolved symbols),
                 *# rename the symbols so they will correctly link to the
                 *# implementations provided by the 'to' side.
                 #*/ \
                /*- if c.from_instance == i -*/ \
                    /*- for m in c.from_interface.type.methods -*/ \
                        --redefine-sym /*? c.from_interface.name ?*/_/*? m.name ?*/="camkes /*? c.to_instance.name ?*/_/*? c.to_interface.name ?*/_/*? m.name ?*/" \
                    /*- endfor -*/ \
                \
                /*# For all 'to' connection ends (implementations of procedures),
                 *# rename the symbols so they will be found during the next
                 *# linking stage. Note we need to mark them as 'keep global' or
                 *# they will not be visible during the next link.
                 #*/ \
                /*- elif c.to_instance == i -*/ \
		/*- if "%s_%s" % (i.name, c.to_interface.name) in instancelist -*/ \
		    /*- continue -*/ \
		/*- endif -*/ \
		/*- do instancelist.append("%s_%s" % (i.name, c.to_interface.name)) -*/ \
                    /*- for m in c.to_interface.type.methods -*/ \
                        --redefine-sym /*? c.to_interface.name ?*/_/*? m.name ?*/="camkes /*? c.to_instance.name ?*/_/*? c.to_interface.name ?*/_/*? m.name ?*/" \
                        --keep-global-symbol "camkes /*? c.to_instance.name ?*/_/*? c.to_interface.name ?*/_/*? m.name ?*/" \
                    /*- endfor -*/ \
                /*- endif -*/ \
            /*- endif -*/ \
            \
        /*- endfor -*/ \
        /*? i.name ?*/.instance.bin $@ # Can't use $^ because it's polluted by common.mk :(
/*- endfor -*/
